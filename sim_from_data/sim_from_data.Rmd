---
title: "Estimations"
author: "Michaela Lukacova"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=FALSE}
# Libraries
library(data.table)
library(survival)
library(simevent)
library(ggplot2)
library(prodlim)
library(rstpm2)
theme_set(theme_bw())
```

# T2D

## Generate data

```{r}
set.seed(373)
data <- simT2D(N = 10000, beta_L0_L = 0, beta_L0_D = 0, beta_L_D = 0)
```

## Estimation

We fit the models

```{r}
# Transform data into tstart tstop format
data_int <- IntFormatData(data, N_cols = 6)

# Fit Cox models
cox_death <- coxph(Surv(tstart, tstop, Delta == 1) ~ L0 + A0 + L, data = data_int)
cox_t2d <- coxph(Surv(tstart, tstop, Delta == 2) ~ L0 + A0, data = data_int[L == 0])
```

A little test

```{r}
predict_data <- data.frame("A0" = c(1,1), "L0" = c(0.5, 0.5), "L" = c(0,1))

basehazz_t2d <- basehaz(cox_t2d, centered = TRUE)
basehazz_death <- basehaz(cox_death, centered = TRUE)
cox_term_t2d <- exp(predict(cox_t2d, newdata=predict_data, type="lp"))
cox_term_death <- exp(predict(cox_death, newdata=predict_data, type="lp"))
cum_int_t2d <- outer(basehazz_t2d[['hazard']], cox_term_t2d, "*")
cum_int_death <- outer(basehazz_death[['hazard']], cox_term_death, "*")

true_surv_death_func1 <- function(t) exp( - 0.1  * t^(1.1)) # * exp(1 * 0.5 + 0 * (-1) + 0 * 1))
true_surv_death_func2 <- function(t) exp( - 0.1  * t^(1.1)) # * exp(1 * 0.5 + 0 * (-1) + 1 * 1))
true_surv_t2d_func <- function(t) exp( - 0.1  * t^(1.1)) # * exp(1 * 0.5 + -1 * 1))

gridExtra::grid.arrange(
  ggplot(data = data.frame(x = basehazz_death$time, y = exp(-cum_int_death[,1])))+
    geom_line(aes(x = x, y = y), color = "red") +
    geom_function(fun = true_surv_death_func1),
  ggplot(data = data.frame(x = basehazz_death$time, y = exp(-cum_int_death[,2])))+
    geom_line(aes(x = x, y = y), color = "red") +
    geom_function(fun = true_surv_death_func2),
  ggplot(data = data.frame(x = basehazz_t2d$time, y = exp(-cum_int_t2d[,1])))+
    geom_line(aes(x = x, y = y), color = "red") +
    geom_function(fun = true_surv_t2d_func),
  nrow = 2)
```

Estimates quite well. 

## Simulation function

In order to simulate new data from an observed data set, we have to estimate the intensities of the various processes. In the following we do this by assuming a Cox model. We estimate the regression parameters by Cox regression and the baseline hazard by the Breslow estimator, as described in~\ref{sec:xxx}. Since we know that data is generated in this way, this is quite a sensible procedure. However in real life, many other non parametric estimation procedures could be more reasonable. We use functions from the `survival` package to estimate the necessary quantities, specifically the `basehaz`, `coxph` and `predict` functions. 

Once the intensities of the processes have been estimated, we initialize the simulated data by making $N$ draws from the empirical distribution of the baseline covariates of the observed data. We initialize $T_0$ as $0$, and a vector that keeps track of the alive individuals. 

Then as long as we have individuals that are alive, we for each alive individual calculate the cumulative intensity of the various processes. We use the estimates obtained from the Cox regression and the Breslow estimator. In order to simulate the next event time $T_k = T_{k-1} + W_k$ by finding the next event time of each event $T_k^x$ and taking the minimum. From Section~\ref{sec:xxx} we remember that the event specific waiting times $W_k^x$ are distributed with cumulative intensity
$$\tilde{\Lambda}^x(u|T_{k-1} = t) = \Lambda^x(u + t) - \Lambda^x(t)$$
And that
$$(\tilde{\Lambda}^x)^{-1}(-\log(U)) \sim \tilde{\Lambda}^x(u)$$
Where $U$ is a uniform random variable. The inverse cumulative intensity of the waiting times is given by
$$(\tilde{\Lambda}^x)^{-1}(u |T_{k-1} = t, \mathcal{F}_{(u+t)-}) = \Lambda^{-1}_x(-\log u + t) - \Lambda(t|F_{t-})|\mathcal{F}_{(u+t)-}) - t$$
So in order to simulate event times, we draw uniform random variables take the minus log and of this number take the inverse cumulative intensity and subtract $t$. The simulation procedure is summarized in Table~\ref{tab:xxx}. The simulation procedure is implemented in the function `simEventDataCox` below. 

```{r}
simEventDataCox <- function(N, 
                            cox_fits,
                            L0_old, 
                            A0_old,
                            max_events = 3, 
                            proc_names = c("D", "L"),
                            n_event_max = c(1,1),
                            term_events = 1) {
  
  # Initialize
  num_events <- length(cox_fits)                          # Number of events
  alive <- 1:N                                            # Vector for keeping track of who is alive
  num_alive <- N                                          # Number of alive individuals
  T_k <- rep(0, N)                                        # Last event time
  
  # Matrix for storing data
  sim_data <- matrix(nrow = N, ncol = (2 + num_events))
  colnames(sim_data) <- c("L0", "A0", proc_names)
  sim_data[,1] <- sample(L0_old, N, replace = TRUE)       # sample with replacement from old data
  sim_data[,2] <- sample(A0_old, N, replace = TRUE)       # sample with replacement from old data
  sim_data[,3:(num_events+2)] <- 0
  sim_data <- data.frame(sim_data)
  
  # List for results
  res_list <- vector("list", max_events)                  # For results
  idx <- 1                                                # Index
  
  # Function to find the cumulative intensity 
  cum_int <- function(int_vals, time_vals, t) {
    cum_int_t <- int_vals[time_vals <= t]                 # All the cum.int. values at times smaller than t
    ifelse(length(cum_int_t) == 0, 0, max(cum_int_t))     # We take the max of these, or if there are none return 0
  }
  
  # Function to find the inverse cumulative intensity
  inv_cum_int <- function(int_vals, time_vals, p) {
    T_k_1 <- time_vals[int_vals <= p]                      # We find the times for which intensity > p
    ifelse(length(T_k_1) == 0, Inf, max(T_k_1))            # We find the inverse cumulative intensity
  }
  
  # Base hazard
  basehazz_list <- lapply(cox_fits, function(model) basehaz(model, centered = FALSE))
  # Jump times of the base hazard
  jump_times <- lapply(basehazz_list, function(df) df[["time"]])
  basehazz_list <- lapply(basehazz_list, function(df) df[["hazard"]])
  
  while(length(alive) != 0){
    # Calculate the Cox term
    cox_term <- lapply(cox_fits, 
                       function(model) exp(predict(model, newdata = sim_data, type="lp", reference = "zero")))
    
    # Calculate the cumulative intensity
    cumInt_list <- Map(function(base_vec, cox_vec) {
    outer(base_vec, cox_vec, "*")
    }, basehazz_list, cox_term)
    
    # We find the cumulative intensity of event j and the ith individual at the event time T_k
    cum_int_Tk <- matrix(ncol = num_events, nrow = num_alive)
    for(j in 1:num_events){
      cum_int_Tk[,j] <- sapply(1:num_alive, function(i) cum_int(cumInt_list[[j]][,i], jump_times[[j]], T_k[i]))
    }
  
    # Simulate the uniform random variable
    U <- matrix(-log(runif(num_alive * num_events)), ncol = num_events)         # matrix for the random draws
    V <- U + cum_int_Tk
    
    # Find the event times
    event_times <- matrix(ncol = num_events, nrow = num_alive)                  # matrix for event times
    for(j in 1:num_events){
      event_times[,j] <- sapply(1:num_alive, function(i) inv_cum_int(cumInt_list[[j]][,i], jump_times[[j]], V[i,j]))
    }
    
    # How many times can you experience the various events?
    for(j in 1:num_events){
      event_times[sim_data[, (2+j)] == n_event_max[j], j] <- Inf
    }
    
    # The next event is the minimum of these events
    T_k <- apply(event_times, 1, min)
    Deltas <- apply(event_times, 1, which.min)
    
    # Update event counts
    for(i in 1:num_alive){
      sim_data[i, (Deltas[i] + 2)] <- sim_data[i, (Deltas[i] + 2)] + 1
    }
    
    # Store data
    kth_event <- data.table(ID = alive,
                            Time = T_k,
                            Delta = Deltas)
  
    res_list[[idx]] <- cbind(kth_event, data.table::as.data.table(sim_data))
    idx <- idx + 1
    
    # Who is still alive?
    alive <- alive[!(Deltas %in% term_events)]
    num_alive <- length(alive)
    # For the next iteration we only keep data from individuals alive
    T_k <- T_k[alive] 
    sim_data <- sim_data[alive, , drop = FALSE]
  }
  
  res <- data.table::rbindlist(res_list)
  setkey(res, ID)
  return(res)
}
```

## Simulate new data

```{r}
cox_fits <- list(death = cox_death, t2d = cox_t2d)
new_data <- simEventDataCox(5000, cox_fits, L0_old = data$L0, A0_old = data$A0)
```


## check whether simulated data has the desired intensitities...

```{r}
# Transform data into tstart tstop format
data_int2 <- IntFormatData(new_data, N_cols = 6:7)

# Fit Cox models
cox_death2 <- coxph(Surv(tstart, tstop, Delta == 1) ~ L0 + A0 + L, data = data_int2)
cox_t2d2 <- coxph(Surv(tstart, tstop, Delta == 2) ~ L0 + A0, data = data_int2[L == 0])
basehazz_t2d2 <- basehaz(cox_t2d2, centered = TRUE)
basehazz_death2 <- basehaz(cox_death2, centered = TRUE)

predict_data <- data.frame("A0" = c(1,1), "L0" = c(0.5, 0.5), "L" = c(0,1))
cox_term_t2d2 <- exp(predict(cox_t2d2, newdata=predict_data, type="lp"))
cox_term_death2 <- exp(predict(cox_death2, newdata=predict_data, type="lp"))
cum_int_t2d2 <- outer(basehazz_t2d2[['hazard']], cox_term_t2d2, "*")
cum_int_death2 <- outer(basehazz_death2[['hazard']], cox_term_death2, "*")

gridExtra::grid.arrange(
  ggplot()+
    geom_line(aes(x = basehazz_death$time, y = exp(-cum_int_death[,1])), color = "red") +
    geom_line(aes(x = basehazz_death2$time, y = exp(-cum_int_death2[,1])), color = "blue") + 
    geom_function(fun = true_surv_death_func1),
  ggplot()+
    geom_line(aes(x = basehazz_death$time, y = exp(-cum_int_death[,2])), color = "red") +
    geom_line(aes(x = basehazz_death2$time, y = exp(-cum_int_death2[,2])), color = "blue") + 
    geom_function(fun = true_surv_death_func2),
  ggplot()+
    geom_line(aes(x = basehazz_t2d$time, y = exp(-cum_int_t2d[,1])), color = "red") +
    geom_line(aes(x = basehazz_t2d2$time, y = exp(-cum_int_t2d2[,1])), color = "blue") + 
    geom_function(fun = true_surv_t2d_func),
  ggplot()+
    geom_line(aes(x = basehazz_t2d$time, y = exp(-cum_int_t2d[,2])), color = "red") +
    geom_line(aes(x = basehazz_t2d2$time, y = exp(-cum_int_t2d2[,2])), color = "blue") + 
    geom_function(fun = true_surv_t2d_func),
  nrow = 2)
```

Så længe vi ikke har cox effekter ser det ud til at virke. 

## Trying with competing risk data

```{r}
set.seed(373)
data <- simCRdata(50000)
predict_data <- data.frame("A0" = 0, "L0" = 0)
true_surv_death_func <- function(t) exp( - 0.1  * t^(1.1)) 
true_surv_t2d_func <- function(t) exp( - 0.1  * t^(1.1))

# Fit Cox models
cox_death <- coxph(Surv(Time, Delta == 1) ~ L0 + A0, data = data)
cox_t2d <- coxph(Surv(Time, Delta == 2) ~ L0 + A0, data = data)
surv_death <- survfit(cox_death, newdata = predict_data, method = "breslow")
surv_t2d <- survfit(cox_t2d, newdata = predict_data, method = "breslow")

cox_fits <- list(death = cox_death, t2d = cox_t2d)
new_data <- simEventDataCox(3000, cox_fits, L0_old = data$L0, term_events = c(1,2), A0_old = data$A0)

# Fit Cox models
cox_death2 <- coxph(Surv(Time, Delta == 1) ~ L0 + A0, data = new_data[Time != Inf])
cox_t2d2 <- coxph(Surv(Time, Delta == 2) ~ L0 + A0, data = new_data[Time != Inf])

surv_death2 <- survfit(cox_death2, newdata = predict_data, method = "breslow")
surv_t2d2 <- survfit(cox_t2d2, newdata = predict_data, method = "breslow")

ggplot()+
  geom_line(aes(x = surv_death$time, y = surv_death$surv), color = "red") +
  geom_line(aes(x = surv_death2$time, y = surv_death2$surv), color = "blue") +
  geom_function(fun = true_surv_death_func)

ggplot()+
  geom_line(aes(x = surv_t2d$time, y = surv_t2d$surv), color = "red") +
  geom_line(aes(x = surv_t2d2$time, y = surv_t2d2$surv), color = "blue") +
  geom_function(fun = true_surv_t2d_func)
```

## Trying with competing risk data with effects

```{r}
set.seed(373)
beta <- matrix(rnorm(3*2), nrow = 2)
data <- simCRdata(50000, beta = beta)
predict_data <- data.frame("L0" = 0, "A0" = 0)
true_surv_death_func <- function(t) exp( - 0.1  * t^(1.1)*exp(sum(beta[,2] * predict_data)))
true_surv_t2d_func <- function(t) exp( - 0.1  * t^(1.1)*exp(sum(beta[,3] * predict_data)))

# Fit Cox models
cox_death <- coxph(Surv(Time, Delta == 1) ~ L0 + A0, data = data)
cox_t2d <- coxph(Surv(Time, Delta == 2) ~ L0 + A0, data = data)
surv_death <- survfit(cox_death, newdata = predict_data, method = "breslow")
surv_t2d <- survfit(cox_t2d, newdata = predict_data, method = "breslow")

cox_fits <- list(death = cox_death, t2d = cox_t2d)
new_data <- simEventDataCox(3000, cox_fits, L0_old = data$L0, term_events = c(1,2), A0_old = data$A0)

# Fit Cox models
cox_death2 <- coxph(Surv(Time, Delta == 1) ~ L0 + A0, data = new_data)
cox_t2d2 <- coxph(Surv(Time, Delta == 2) ~ L0 + A0, data = new_data)

surv_death2 <- survfit(cox_death2, newdata = predict_data, method = "breslow")
surv_t2d2 <- survfit(cox_t2d2, newdata = predict_data, method = "breslow")

ggplot()+
  geom_line(aes(x = surv_death$time, y = surv_death$surv), color = "red") +
  geom_line(aes(x = surv_death2$time, y = surv_death2$surv), color = "blue") +
  geom_function(fun = true_surv_death_func)

ggplot()+
  geom_line(aes(x = surv_t2d$time, y = surv_t2d$surv), color = "red") +
  geom_line(aes(x = surv_t2d2$time, y = surv_t2d2$surv), color = "blue") +
  geom_function(fun = true_surv_t2d_func)
```

Problemet er hvordan covariaterne influencerer, min funktion som estimerer på simuleret data, estimerer som om covariaterne var nul altid!

https://github.com/kkholst/mets/blob/develop/R/sim-pc-hazard.R
