---
title: 'Benschmarking and profiling'
output: html_document
date: "2024-10-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Libraries
library(data.table)
library(survival)
library(simevent)
library(ggplot2)
library(microbenchmark)
theme_set(theme_bw())
```

# Optimizing the simulation algorithm


```{r}
profvis::profvis({
simEventData <- function(N,                      # Number of individuals
                         beta = NULL,            # Effects
                         eta = NULL,             # Shape parameters
                         nu = NULL,              # Scale parameters
                         at_risk = NULL,         # Function defining the setting
                         term_deltas = c(0,1),   # Terminal events
                         max_cens = Inf,         # Followup time
                         add_cov = NULL,         # Additional baseline covariates
                         override_beta = NULL,   # Override beta
                         max_events = 10,        # Maximal events per individual
                         lower = 10^(-15),       # Lower bound for ICH
                         upper = 200,            # Upper bound for ICH
                         gen_A0 = NULL,          # Generation of A0
                         at_risk_cov = NULL
){
  ID <- NULL

  ############################ Check and useful quantities #####################
  # Check of add_cov
  if(!(is.null(add_cov) | is.list(add_cov))){
    stop("add_cov needs to be list of random functions")
  }

  # Number of additional baseline covariates
  num_add_cov <- length(add_cov)

  # Determine number of events
  num_events <- if (!is.null(eta)) length(eta) else
    if (!is.null(nu)) length(nu) else
      if (!is.null(beta)) ncol(beta) else 4

  # Useful indices
  N_start <- 3 + num_add_cov
  N_stop <- 2 + num_add_cov + num_events

  ############################ Default values ##################################

  # Set default values for beta, eta, and nu
  beta <- if (!is.null(beta)) beta else matrix(0, nrow = N_stop, ncol = num_events)
  colnames(beta) <- paste0("N", seq(0, num_events -1))

  if((N_stop) != nrow(beta)){
    stop("Number of rows in beta should equal the sum of number of event and
         number of additional covariates + 2")
  }

  eta  <- if (!is.null(eta)) eta   else rep(0.1, num_events)
  nu   <- if (!is.null(nu)) nu     else rep(1.1, num_events)

  # Check of dimensions
  if(num_events != length(nu) || num_events != ncol(beta)){
    stop("Length of eta should be equal to nu and number of columns of beta")
  }

  # Default at_risk
  if(is.null(at_risk)){
    riskss <- rep(1, num_events)
    at_risk <- function(events, covariates) return(riskss)
  }

  # Default A0 generation
  if(is.null(gen_A0)){
    gen_A0 <- function(N, L0) stats::rbinom(N, 1, 0.5)
  }

  # Matrix for storing values
  simmatrix <- matrix(0, nrow = N, ncol = (2 + num_events + num_add_cov))

  # Naming of matrices
  if (is.null(names(add_cov)) && num_add_cov != 0) {
      colnames(simmatrix) <- c("L0", "A0", paste0("L", seq_len(num_add_cov)), colnames(beta))
  } else {
      colnames(simmatrix) <- c("L0", "A0", names(add_cov), colnames(beta))
  }

  rownames(beta) <- colnames(simmatrix)

  # Filling out beta matrix
  if(!is.null(override_beta)){
      for (bb in 1:length(override_beta)) {
          if (names(override_beta)[bb] %in% rownames(beta)) {
              beta[names(override_beta)[bb], names(override_beta[[bb]])] <- override_beta[[bb]]
          } else {
              beta <- rbind(beta, matrix(0, nrow = 1, ncol = ncol(beta)))
              beta[nrow(beta), names(override_beta[[bb]])] <- override_beta[[bb]]
              rownames(beta)[nrow(beta)] <- names(override_beta)[bb]
          }
      }
  }

  ############################ Functions #######################################

  # Proportional hazard
  calculate_phi <- function(simmatrix) {
    if(nrow(beta) == N_stop) return(exp(simmatrix %*% beta)) else {
      obj <- as.data.frame(simmatrix)
      X <- sapply(rownames(beta), function(expr) {
        eval(parse(text = expr), envir = obj)
      })
      effects <- as.matrix(X) %*% beta
      return(exp(effects))
    }
  }

  # Intensities
  lambda <- function(t, i) {
    risk_vec <- at_risk_cov[,i] * at_risk(simmatrix[i, N_start:N_stop])
    risk_vec * eta * nu * t^(nu - 1) * phi[i,]
  }

  # If all events have the same parameter, the inverse of the cumulative hazard simplifies
  if(all(nu[1] == nu) && all(eta[1] == eta)){
    inverse_sc_haz <- function(p, t, i) {
      riskss <- at_risk(simmatrix[i, N_start:N_stop]) * at_risk_cov[,i]
      denom <- sum(riskss * eta * phi[i,])
      (p / denom + t^nu[1])^(1 / nu[1]) - t
    }
  # Otherwise we use a numerical inverse coded in rcpp
  } else{
    inverse_sc_haz <- function(p, t, i) {
      riskss <- at_risk(simmatrix[i, N_start:N_stop]) * at_risk_cov[,i]
      inverseScHaz(p, t, lower = lower, upper = upper, eta = eta, nu = nu, phi = phi[i,],
                   at_risk = riskss)

    }
  }

  # Event probabilities
  probs <- function(t, i){
    if(t == max_cens) return(c(1, rep(0, (num_events - 1))))
    probs <- lambda(t, i)
    summ <- sum(probs)
    probs / summ
  }

  ############################ Initializing Simulations ########################

  # Draw baseline covariates
  simmatrix[,1] <- stats::runif(N)                   # L0
  simmatrix[,2] <- gen_A0(N, simmatrix[,1])          # A0

  # Generate additional covariates if distributions are specified
  if (num_add_cov != 0) {
    simmatrix[,3:(2+length(add_cov))] <- sapply(add_cov, function(f) f(N))
  }

  # Covariate dependent at_risk
  if(is.null(at_risk_cov)){
    at_risk_cov <- matrix(1, nrow = num_events, ncol = N)
  }
  else{
    at_risk_cov <- apply(simmatrix[,1:(N_start - 1)], 1, at_risk_cov)
  }

  # Initialize
  T_k <- rep(0,N)                                    # Time 0
  alive <- 1:N                                       # Keeping track of who is alive
  res_list <- vector("list", max_events)             # For results
  idx <- 1                                           # Index


  ############################ Simulations #####################################

  while(length(alive) != 0){
    # Simulate time
    V <- -log(stats::runif(N))
    phi <- calculate_phi(simmatrix)
    W <- sapply(alive, function(i) inverse_sc_haz(V[i], T_k[i], i))
    T_k[alive] <- T_k[alive] + W

    # Maximal censoring time
    T_k[T_k > max_cens] <- max_cens

    # Simulate event
    probs_mat <- sapply(alive, function(i) probs(T_k[i], i), simplify = "array")
    Deltas <- sampleEvents(probs_mat)

    # Update event counts
    simmatrix[cbind(alive, 2 + num_add_cov + Deltas + 1)] <-
      simmatrix[cbind(alive, 2 + num_add_cov + Deltas + 1)] + 1

    # Store data
    kth_event <- data.table(ID = alive,
                            Time = T_k[alive],
                            Delta = Deltas)

    res_list[[idx]] <- cbind(kth_event, data.table::as.data.table(simmatrix[alive, , drop = FALSE]))
    idx <- idx + 1

    # Who is still alive and uncensored?
    alive <- alive[!Deltas %in% term_deltas]
  }

  res <- data.table::rbindlist(res_list)
  setkey(res, ID)

  return(res)
}

simEventData(10^5)
})
```


```{r}
simEventDataOLD <- function(N,                      # Number of individuals
                         beta = NULL,            # Effects
                         eta = NULL,             # Shape parameters
                         nu = NULL,              # Scale parameters
                         at_risk = NULL,         # Function defining the setting
                         term_deltas = c(0,1),   # Terminal events
                         max_cens = Inf,         # Followup time
                         add_cov = NULL,         # Additional baseline covariates
                         override_beta = NULL,   # Override beta
                         max_events = 10,        # Maximal events per individual
                         lower = 10^(-15),       # Lower bound for ICH
                         upper = 200,            # Upper bound for ICH
                         gen_A0 = NULL           # Generation of A0
){
  ID <- NULL

  ############################ Check and useful quantities #####################
  # Check of add_cov
  if(!(is.null(add_cov) | is.list(add_cov))){
    stop("add_cov needs to be list of random functions")
  }

  # Number of additional baseline covariates
  num_add_cov <- length(add_cov)

  # Determine number of events
  num_events <- if (!is.null(eta)) length(eta) else
    if (!is.null(nu)) length(nu) else
      if (!is.null(beta)) ncol(beta) else 4

  # Useful indices
  N_start <- 3 + num_add_cov
  N_stop <- 2 + num_add_cov + num_events

  ############################ Default values ##################################

  # Set default values for beta, eta, and nu
  beta <- if (!is.null(beta)) beta else matrix(0, nrow = N_stop, ncol = num_events)
  colnames(beta) <- paste0("N", seq(0, num_events -1))

  if((N_stop) != nrow(beta)){
    stop("Number of rows in beta should equal the sum of number of event and
         number of additional covariates + 2")
  }

  eta  <- if (!is.null(eta)) eta   else rep(0.1, num_events)
  nu   <- if (!is.null(nu)) nu     else rep(1.1, num_events)

  # Check of dimensions
  if(num_events != length(nu) || num_events != ncol(beta)){
    stop("Length of eta should be equal to nu and number of columns of beta")
  }

  # Default at_risk
  if(is.null(at_risk)){
    riskss <- rep(1, num_events)
    at_risk <- function(events) return(riskss)
  }
  # Default A0 generation
  if(is.null(gen_A0)){
    gen_A0 <- function(N, L0) stats::rbinom(N, 1, 0.5)
  }

  # Matrix for storing values
  simmatrix <- matrix(0, nrow = N, ncol = (2 + num_events + num_add_cov))

  # Generate additional covariates if distributions are specified
  if (num_add_cov != 0) {
    simmatrix[,3:(2+length(add_cov))] <- sapply(add_cov, function(f) f(N))
  }

  # Naming of matrices
  if (is.null(names(add_cov)) && num_add_cov != 0) {
      colnames(simmatrix) <- c("L0", "A0", paste0("L", seq_len(num_add_cov)), colnames(beta))
  } else {
      colnames(simmatrix) <- c("L0", "A0", names(add_cov), colnames(beta))
  }

  rownames(beta) <- colnames(simmatrix)

  # Filling out beta matrix
  if(!is.null(override_beta)){
      for (bb in 1:length(override_beta)) {
          if (names(override_beta)[bb] %in% rownames(beta)) {
              beta[names(override_beta)[bb], names(override_beta[[bb]])] <- override_beta[[bb]]
          } else {
              beta <- rbind(beta, matrix(0, nrow = 1, ncol = ncol(beta)))
              beta[nrow(beta), names(override_beta[[bb]])] <- override_beta[[bb]]
              rownames(beta)[nrow(beta)] <- names(override_beta)[bb]
          }
      }
  }

  ############################ Functions #######################################

  # Proportional hazard
  calculate_phi <- function(simmatrix) {
    if(nrow(beta) == N_stop) return(exp(simmatrix %*% beta)) else {
      obj <- as.data.frame(simmatrix)
      X <- sapply(rownames(beta), function(expr) {
        eval(parse(text = expr), envir = obj)
      })
      effects <- as.matrix(X) %*% beta
      return(exp(effects))
    }
  }

  # Intensities
  lambda <- function(t, i) {
    risk_vec <- at_risk(simmatrix[i, N_start:N_stop])
    risk_vec * eta * nu * t^(nu - 1) * phi[i,]
  }

  # If all events have the same parameter, the inverse of the cumulative hazard simplifies
  if(all(nu[1] == nu) && all(eta[1] == eta)){
    inverse_sc_haz <- function(p, t, i) {
      denom <- sum(at_risk(simmatrix[i, N_start:N_stop]) * eta * phi[i,])
      (p / denom + t^nu[1])^(1 / nu[1]) - t
    }
  # Otherwise we use a numerical inverse coded in rcpp
  } else{
    inverse_sc_haz <- function(p, t, i) {
      inverseScHaz(p, t, lower = lower, upper = upper, eta = eta, nu = nu,
                     phi = phi[i,],
                   at_risk = at_risk(simmatrix[i, N_start:N_stop]))

    }
  }

  # Event probabilities
  probs <- function(t, i){
    if(t == max_cens) return(c(1, rep(0, (num_events - 1))))
    probs <- lambda(t, i)
    summ <- sum(probs)
    probs / summ
  }

  ############################ Initializing Simulations ########################

  # Draw baseline covariates
  simmatrix[,1] <- stats::runif(N)                   # L0
  simmatrix[,2] <- gen_A0(N, simmatrix[,1])          # A0

  # Initialize
  T_k <- rep(0,N)                                    # Time 0
  alive <- 1:N                                       # Keeping track of who is alive
  res_list <- vector("list", max_events)             # For results
  idx <- 1                                           # Index


  ############################ Simulations #####################################

  while(length(alive) != 0){
    # Simulate time
    V <- -log(stats::runif(N))
    phi <- calculate_phi(simmatrix)
    W <- sapply(alive, function(i) inverse_sc_haz(V[i], T_k[i], i))
    T_k[alive] <- T_k[alive] + W

    # Maximal censoring time
    T_k[T_k > max_cens] <- max_cens

    # Simulate event
    probs_mat <- sapply(alive, function(i) probs(T_k[i], i), simplify = "array")
    Deltas <- sampleEvents(probs_mat)

    # Update event counts
    simmatrix[cbind(alive, 2 + num_add_cov + Deltas + 1)] <-
      simmatrix[cbind(alive, 2 + num_add_cov + Deltas + 1)] + 1

    # Store data
    kth_event <- data.table(ID = alive,
                            Time = T_k[alive],
                            Delta = Deltas)

    res_list[[idx]] <- cbind(kth_event, data.table::as.data.table(simmatrix[alive, , drop = FALSE]))
    idx <- idx + 1

    # Who is still alive and uncensored?
    alive <- alive[!Deltas %in% term_deltas]
  }

  res <- data.table::rbindlist(res_list)
  setkey(res, ID)

  return(res)
}
```


```{r}
my_bench <- bench::press(
  N = 2^(10:16),
  {bench::mark(
    "cov_at_risk1" = simEventData(N, at_risk_cov = at_risk_cov),
    "cov_at_risk2" = simEventData(N),
    "gammel" = simEventDataOLD(N),
    check = FALSE)})

summary(my_bench)
autoplot(my_bench)
```

```{r}
mat <- matrix(rnorm(10^7), nrow = 10^7, ncol = 10)
mat_t <- t(mat)

func1 <- function() for(i in 1:10^7) mat[i,]
func2 <- function() for(i in 1:10^7) mat_t[,i]


bench::mark(
    "cov_at_risk" = func1,
    "gammel" = func2,
    check = FALSE)
```




